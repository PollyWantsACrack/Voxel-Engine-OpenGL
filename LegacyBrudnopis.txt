


			case W:
	{
		int x = 1;
		int y = 1;
		int z = 1;
		bool validPos = true;
		for (int i = 0; i < chunk->blocks.size(); i++)
		{
			if (chunk->blocks.at(i).blockType == 0)
			{
				continue;
			}


			if (
				(cameraPos.x > chunk->blocks[i].cubeCenter.x - 0.5f  && cameraPos.x < chunk->blocks[i].cubeCenter.x + 0.5f) &&
				(cameraPos.y > chunk->blocks[i].cubeCenter.y - 0.5f && cameraPos.y < chunk->blocks[i].cubeCenter.y + 0.5f) &&
				(cameraPos.z > chunk->blocks[i].cubeCenter.z - 0.5f && cameraPos.z < chunk->blocks[i].cubeCenter.z + 0.5f)
				)
			{
				validPos = false;
			}

			
			

			


		}
		std::cout << validPos;
		if (!validPos)
		{
			cameraPos += cameraSpeed * glm::vec3(0, 0, 0);
			break;
		}
		else {
			cameraPos += cameraSpeed * glm::vec3(cameraFront.x*x, cameraFront.y*y, cameraFront.z*z);
			break;
		}
	}




	case W:
	{
		int x = 1;
		int y = 1;
		int z = 1;
		bool validPos = true;
		for (int i = 0; i < chunk->blocks.size(); i++)
		{
			if (chunk->blocks.at(i).blockType == 0)
			{
				continue;
			}


			if ((cameraPos + cameraSpeed * glm::vec3(cameraFront.x, cameraFront.y, cameraFront.z)).x > chunk->blocks[i].cubeCenter.x - 0.5f && (cameraPos + cameraSpeed * glm::vec3(cameraFront.x, cameraFront.y, cameraFront.z)).x < chunk->blocks[i].cubeCenter.x + 0.5f)
			{
				x = 0;
			}
			if ((cameraPos + cameraSpeed * glm::vec3(cameraFront.x, cameraFront.y, cameraFront.z)).y > chunk->blocks[i].cubeCenter.y - 0.5f && (cameraPos + cameraSpeed * glm::vec3(cameraFront.x, cameraFront.y, cameraFront.z)).y < chunk->blocks[i].cubeCenter.y + 0.5f)
			{
				y = 0;
			}
			if ((cameraPos + cameraSpeed * glm::vec3(cameraFront.x, cameraFront.y, cameraFront.z)).z > chunk->blocks[i].cubeCenter.z - 0.5f && (cameraPos + cameraSpeed * glm::vec3(cameraFront.x, cameraFront.y, cameraFront.z)).z < chunk->blocks[i].cubeCenter.z + 0.5f)
			{
				z = 0;
			}
			
		}
		cameraPos += cameraSpeed * glm::vec3(cameraFront.x*x, cameraFront.y*y, cameraFront.z*z);
		break;
		
	}








	case W:
	{
		bool validPosX = true;
		bool validPosY = true;
		bool validPosZ = true;
		bool validPos = true;
		int x = 1;
		int y = 1;
		int z = 1;
		for (int i = 0; i < chunk->blocks.size(); i++)
		{
			if (chunk->blocks.at(i).blockType == 0)
			{
				continue;
			}
			glm::vec3 predictedPosition = cameraPos + cameraSpeed * glm::vec3(cameraFront.x, cameraFront.y, cameraFront.z);

			if ((predictedPosition.x > chunk->blocks[i].cubeCenter.x - 0.5f) && (predictedPosition.x < chunk->blocks[i].cubeCenter.x + 0.5f))
			{
				validPosX = false;
			}
			if ((predictedPosition.y > chunk->blocks[i].cubeCenter.y - 0.5f) && (predictedPosition.y < chunk->blocks[i].cubeCenter.y + 0.5f))
			{
				validPosY = false;
			}
			if ((predictedPosition.z > chunk->blocks[i].cubeCenter.z - 0.5f) && (predictedPosition.z < chunk->blocks[i].cubeCenter.z + 0.5f))
			{
				validPosZ = false;
			}

			if (!validPosX && !validPosY && !validPosZ)
			{
				validPos = false;
			}

			if ((cameraPos.x + cameraSpeed * cameraFront.x > chunk->blocks[i].cubeCenter.x - 0.5f) && (cameraPos.x + cameraSpeed * cameraFront.x < chunk->blocks[i].cubeCenter.x + 0.5f))
			{
				x = 0;
			}
			if ((cameraPos.y + cameraSpeed * cameraFront.y > chunk->blocks[i].cubeCenter.y - 0.5f) && (cameraPos.y + cameraSpeed * cameraFront.y < chunk->blocks[i].cubeCenter.y + 0.5f))
			{
				y = 0;
			}
			if ((cameraPos.z + cameraSpeed * cameraFront.z > chunk->blocks[i].cubeCenter.z - 0.5f) && (cameraPos.z + cameraSpeed * cameraFront.z < chunk->blocks[i].cubeCenter.z + 0.5f))
			{
				z = 0;
			}

		}
		if (!validPos)
		{
			cameraPos += cameraSpeed * glm::vec3(cameraFront.x*x, cameraFront.y*y, cameraFront.z*z);
			break;
		}
		else {
			cameraPos += cameraSpeed * glm::vec3(cameraFront.x, cameraFront.y, cameraFront.z);
			break;
		}
	}








	if (!validPos)
			{
				if (
					(cameraPos.x + 0.01f > chunk->blocks[i].cubeCenter.x - 0.5f && cameraPos.x + 0.01f < chunk->blocks[i].cubeCenter.x + 0.5f) &&
					(cameraPos.y > chunk->blocks[i].cubeCenter.y - 0.5f && cameraPos.y < chunk->blocks[i].cubeCenter.y + 0.5f) &&
					(cameraPos.z > chunk->blocks[i].cubeCenter.z - 0.5f && cameraPos.z < chunk->blocks[i].cubeCenter.z + 0.5f)
					)
				{
					x = 0;
				}
				if (
					(cameraPos.x > chunk->blocks[i].cubeCenter.x - 0.5f && cameraPos.x < chunk->blocks[i].cubeCenter.x + 0.5f) &&
					(cameraPos.y + 0.01f > chunk->blocks[i].cubeCenter.y - 0.5f && cameraPos.y + 0.01f < chunk->blocks[i].cubeCenter.y + 0.5f) &&
					(cameraPos.z > chunk->blocks[i].cubeCenter.z - 0.5f && cameraPos.z < chunk->blocks[i].cubeCenter.z + 0.5f)
					)
				{
					y = 0;
				}
				if (
					(cameraPos.x > chunk->blocks[i].cubeCenter.x - 0.5f && cameraPos.x < chunk->blocks[i].cubeCenter.x + 0.5f) &&
					(cameraPos.y > chunk->blocks[i].cubeCenter.y - 0.5f && cameraPos.y < chunk->blocks[i].cubeCenter.y + 0.5f) &&
					(cameraPos.z + 0.01f > chunk->blocks[i].cubeCenter.z - 0.5f && cameraPos.z + 0.01f < chunk->blocks[i].cubeCenter.z + 0.5f)
					)
				{
					z = 0;
				}
			}









			std::cout << collisionIndex<<"\n";
			float distanceX = cameraPos.x - chunk->blocks[collisionIndex].cubeCenter.x;
			float distanceY = cameraPos.y - chunk->blocks[collisionIndex].cubeCenter.y;
			float distanceZ = cameraPos.z - chunk->blocks[collisionIndex].cubeCenter.z;

			if (distanceX > distanceY && distanceX > distanceZ)
			{
				x = 0;
			}
			else if (distanceY > distanceZ && distanceY > distanceX)
			{
				y = 0;
			}
			else if(distanceZ > distanceX && distanceZ > distanceY){
				z = 0;
			}




			if (i < 16*16)
			{


				
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(0.0f);


							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(0.0f); vertices.push_back(0.0f);


							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(0.0f);


							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(0.0f);


							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(1.0f);


							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(1.0f); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16); vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(1.0f);

			}
			if (i < 16 * 16*128)
			{
				


							// Front face
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(0.0f);

							// Back face
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(0.0f);

							// Left face
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(0.0f);

							// Right face
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(0.0f);

							// Bottom face
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(0.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(1.0f);

							// Top face
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(1.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(1.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(1.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(1.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(0.0f);
							vertices.push_back(0.0f + i % 16); vertices.push_back(1.0f + i / 16 * 16); vertices.push_back(0.0f + (i / 16) % 16); vertices.push_back(0.0f); vertices.push_back(1.0f);

			}




			for (int i = 0; i < vertices.size();i++)
		{
			std::cout << vertices[i] << " to wiercholek nr " << i << "\n";
	
	}


	glm::vec3 posPrediction;
			posPrediction = cameraPos + cameraSpeed * glm::vec3(cameraFront.x, 0, cameraFront.z);
			if (posPrediction.x >= -0.5f)
			{
				cameraPos += cameraSpeed * glm::vec3(0, 0, cameraFront.z);
				break;
			}
			else {
				cameraPos += cameraSpeed * glm::vec3(cameraFront.x,0,cameraFront.z);
				break;
			}






			
	void Chunk::addBlock(glm::vec3 cameraPos, glm::vec3 cameraFront)
{
	std::vector<int> possibleIndices{};
	bool firstSolidFound = false;
	float offset = 0.1;
	glm::vec3 nextCheckPos{};

	for (int y = 0; y < 1000; y++)
	{
		if (firstSolidFound)
		{
			break;
		}
		offset = offset + 0.1f;
		nextCheckPos = cameraPos + cameraFront * offset;
		for (int i = 0; i < blocks.size(); i++)
		{



			if (
				(blocks[i].cubeCenter.x - 0.5f < nextCheckPos.x && blocks[i].cubeCenter.x + 0.5f > nextCheckPos.x) &&
				(blocks[i].cubeCenter.y - 0.5f < nextCheckPos.y && blocks[i].cubeCenter.y + 0.5f > nextCheckPos.y) &&
				(blocks[i].cubeCenter.z - 0.5f < nextCheckPos.z && blocks[i].cubeCenter.z + 0.5f > nextCheckPos.z) 
				)
			{
				
				possibleIndices.push_back(i);
				if (blocks[i].blockType == 1)
				{
					firstSolidFound = true;
					break;
				}

			}

		}




	}
	int length = possibleIndices.size();
	if (length-2 > -1)
	{
		std::cout << "changing block with type" << blocks[possibleIndices[possibleIndices.size() - 2]].blockType << " to type 1 ";
		blocks[possibleIndices[possibleIndices.size() - 2]].blockType = 1;
	}
		
		
	
	
}




void PhysicsEngine::jump(Player* player, Camera* camera, Chunk* chunk) {
	bool subtracted = false;
	if (playerDuringJump)
	{
		elapsedTime = currentTime - lastTime;
		if (currentTime - lastTime < 0.25f)
		{
			float offset = -8 * (elapsedTime - 0) * (elapsedTime - 1.3);
			



				glm::vec3 predictedPositionY = camera->getCameraPos();
				predictedPositionY.y = camera->getCameraPos().y - camera->getCameraSpeed() - 1.51f;

				for (int i = 0; i < chunk->getChunkSize(); i++)
				{
					if (chunk->getBlockType(i) == 0)
					{
						continue;
					}
					if (
						(predictedPositionY.x > chunk->getBlockCenter(i).x - 0.65f && predictedPositionY.x < chunk->getBlockCenter(i).x + 0.65f) &&
						(predictedPositionY.y > chunk->getBlockCenter(i).y - 0.5f && predictedPositionY.y < chunk->getBlockCenter(i).y + 0.5f) &&
						(predictedPositionY.z > chunk->getBlockCenter(i).z - 0.65f && predictedPositionY.z < chunk->getBlockCenter(i).z + 0.65f)
						)
					{
						playerOnGround = true;
						break;
					}
					else 
					{
						if (!subtracted)
						{
							player->addToPlayerPos(glm::vec3(0.0f, offset / 240, 0.0f));
							subtracted = true;
						}
						else if (subtracted)
						{
							break;
						}
						
						
					
					}				
				}
			jumpProcesStarted = true;
			
		}
		else {
			playerDuringJump = false;
			lastTime = 0.0f;
			elapsedTime = 0.0f;
		}
	}	
}


void PhysicsEngine::jump(Player* player, Camera* camera, Chunk* chunk) {
	bool subtracted = false;
	if (playerDuringJump)
	{
		elapsedTime = currentTime - lastTime;
		if (currentTime - lastTime < 1)
		{
			float offset = -4 * (elapsedTime - 0) * (elapsedTime - 1);
			if (elapsedTime > 0.5f)
			{
				player->substractFromPlayerPos(glm::vec3(0.0f, offset/60, 0.0f));
				std::cout << "Substracting: " << offset<<"\n";
			}
			else if (elapsedTime <= 0.5f)
			{









				glm::vec3 predictedPositionY = camera->getCameraPos();
				predictedPositionY.y = camera->getCameraPos().y - camera->getCameraSpeed() - 1.51f;

				for (int i = 0; i < chunk->getChunkSize(); i++)
				{
					if (chunk->getBlockType(i) == 0)
					{
						continue;
					}
					if (
						(predictedPositionY.x > chunk->getBlockCenter(i).x - 0.65f && predictedPositionY.x < chunk->getBlockCenter(i).x + 0.65f) &&
						(predictedPositionY.y > chunk->getBlockCenter(i).y - 0.5f && predictedPositionY.y < chunk->getBlockCenter(i).y + 0.5f) &&
						(predictedPositionY.z > chunk->getBlockCenter(i).z - 0.65f && predictedPositionY.z < chunk->getBlockCenter(i).z + 0.65f)
						)
					{
						playerOnGround = true;
						break;
					}
					else {
						if (!subtracted)
						{
							player->addToPlayerPos(glm::vec3(0.0f, offset / 60, 0.0f));
							subtracted = true;
						}
						else if (subtracted)
						{
							break;
						}
						
						
					}
				}






				
			}
			jumpProcesStarted = true;
			
		}
		else {
			playerDuringJump = false;
			lastTime = 0.0f;
			elapsedTime = 0.0f;
			jumpProcesStarted = false;
			std::cout << "NOT JUM<PING\n";
		}
	}	
}